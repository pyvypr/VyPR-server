var code_highlight_palette = ["#89c6d9", "#a1cc87", "#f0ad95", "#ded4e7", "#e3e3e3", "d6eff0"];
//var code_highlight_palette = ["red", "blue", "green"];
// global plot data, used for when plot are updated with new data
var plot_visible = false;
var path_visible = false;
var plot_data = null;
var path_plot_data = null;
var path_plot_hash = null;
var selected_binding = undefined;
var sidebar_scroll_timeout = null;
var path_highlight_mode_on = false;
var Store = {
  status : {
    loading : false,
  },
  plot : {
    constraint_html : "",
    type : null,
    show_violations : true,
    show_successes : true,
    current_hash : null
  },
  selected_calls : [],
  selected_tests: [],
  selected_property_hash : null,
  binding_selected : false,
  subatom_selected : false,
  first_point_selected : false,
  type_of_atom : undefined,
  tests_exist : null,
  current_tab : null,
  path_view : false,
  chosen_path_index : 0
};

var start_loading = function() {
  Store.status.loading = true;
}

var stop_loading = function() {
  Store.status.loading = false;
}

var decodeHTML = function (html) {
  var txt = document.createElement('textarea');
  txt.innerHTML = html;
  return txt.value;
}

var html_space_replace = function(){
  var leadingSpaces = arguments[0].length;
  var str = '';
  while(leadingSpaces > 0) {
    str += '&nbsp;';
    leadingSpaces--;
  }
  return str;
}

var subatom_click = function(dict){
  Store.first_point_selected = false;
  app.$emit("subatom-selected", dict)
};

var generate_plot = function(root_obj) {
  var that = root_obj;
  // get the plot type
  var type = Store.plot.type;
  // set global plot data
  // this is used when function calls are selected - if a plot is already being shown,
  // the new data will be merged into the plot
  // plot_visible = true;
  // get global plot data
  var data = plot_data;

  console.log("storing plot data");
  console.log(data);

  // first case: the selected option was to plot verdict severity at a point generated by a simple atom
  if (type == "severity" || type == "observation"){
    axios.post('/get_plot_data_simple/', data).then(function(response){
      var data = response.data.plot_data;
      Store.plot.current_hash = response.data.plot_hash;

      window.open("/display_plot/" + response.data.plot_hash, "plot", "width=1300,height=1000");
    });
  }
  if (type == "between-severity" || type == "between-observation"){
    axios.post('/get_plot_data_between/', data).then(function(response){
      var data = response.data.plot_data;
      Store.plot.current_hash = response.data.plot_hash;

      window.open("/display_plot/" + response.data.plot_hash, "plot", "width=1300,height=1000");
    })
  }
  if (type == "mixed-severity" || type == "mixed-observation"){
    axios.post('/get_plot_data_mixed/', data).then(function(response){
      var data = response.data.plot_data;
      Store.plot.current_hash = response.data.plot_hash;

      window.open("/display_plot/" + response.data.plot_hash, "plot", "width=1300,height=1000");
    })
  }
  if (type == "between-path-severity" || type == "between-path-observation" ||
      type == "simple-path-severity" || type == "simple-path-observation" ||
      type == "mixed-path-severity" || type == "mixed-path-observation") {
    var path_index = Store.chosen_path_index;
    Store.plot.current_hash = path_plot_hash;

    if(type == "simple-path-severity" || type == "between-path-severity" || type == "mixed-path-severity") {

      window.open("/display_path_plot/" + path_plot_hash + "/severity/", "plot", "width=1300,height=1000");

    } else {

      window.open("/display_path_plot/" + path_plot_hash + "/observation/", "plot", "width=1300,height=1000");

    }
  }
};

var highlight_paths = function(root_obj) {
  var that = root_obj;
  // get the plot type
  var type = Store.plot.type;
  var data = plot_data;
  var resp, main_lines, parameter_lines, url;
  if (type == "simple-path"){
    url = '/get_path_data_simple/';
  }
  else if (type == "between-path"){
    var sorted = plot_data["selected_line_numbers"][0] <= plot_data["selected_line_numbers"][1];
    var first_line = sorted ? plot_data["selected_line_numbers"][0] : plot_data["selected_line_numbers"][1];
    var last_line = sorted ? plot_data["selected_line_numbers"][1] : plot_data["selected_line_numbers"][0];
    url = '/get_path_data_between/';
  }
  else if (type == "mixed-path"){
    var sorted = plot_data["selected_line_numbers"][0] <= plot_data["selected_line_numbers"][1];
    var first_line = sorted ? plot_data["selected_line_numbers"][0] : plot_data["selected_line_numbers"][1];
    var last_line = sorted ? plot_data["selected_line_numbers"][1] : plot_data["selected_line_numbers"][0];
    url = '/get_path_data_mixed/';
  }

  axios.post(url, data).then(function(response){
    resp = response.data.parameter_values;
    path_plot_hash = response.data.path_hash;
    console.log(path_plot_hash)
    path_plot_data = resp;

    main_lines = response.data.main_lines;
    parameter_lines = response.data.parameters;
    console.log("parameter lines received");
    console.log(parameter_lines);

    // the selected option was to highlight the paths by severity
    console.log("computing path data");
    var lines_to_colors = []; // this list will contain pairs of line numbers and their colours

    if(resp.length > 0) {

      // severities observed along any path
      var all_severities = resp[0]["severities"];
      for (var i=1; i<resp.length; i++) {
        all_severities = all_severities.concat(resp[i]["severities"]);
      }

      // min and max severity value observed along any path - we need range
      var min_sev = Math.min(...all_severities);
      var max_sev = Math.max(...all_severities);

      // 0 is fixed halfway between green and red, we want to place the average value
      // with red being the worst violation and green the success with largest margin
      // in case all obsrvations were successes, the scale will only go from yellow to green
      // we know all averages are also positive in this case so no worries about div by zero
      var negative_range = min_sev<0 ? (0 - min_sev) : 0;
      var positive_range = max_sev>0 ? (max_sev) : 0;

      for (var i=0; i<resp.length; i++) {
        var avg = 0;
        for (var j=0; j<resp[i]["severities"].length; j++){
          avg += resp[i]["severities"][j];
        }
        avg /= resp[i]["severities"].length;
        var avg_index;
        if (avg < 0) {
          avg_index = Math.round((avg - min_sev)/negative_range * 60);
        } else {
          avg_index = Math.round(60 + avg/positive_range * 60);
        }
        var dict = {lines: resp[i]["lines"],
                    color: "hsl("+avg_index+", 78%, 90%)"};
        lines_to_colors.push(dict);
      }
      var data = {
        first_line: first_line,
        last_line: last_line,
        lines_to_colors: lines_to_colors,
        main_lines: main_lines,
        parameter_lines: parameter_lines
      };
    } else {
      var data = {
        first_line: first_line,
        last_line: last_line,
        lines_to_colors: [],
        main_lines: main_lines,
        parameter_lines: []
      };
    }
    that.$root.$emit('path-data-ready', data);
  })

};

var is_before = function(str1, str2) {
  // determining if datetime in str1 shows a time earlier then the one in str2
  // format DD/MM/YYYY hh:mm:ss
  var date1 = str1.split(" ")[0].split("/");
  var date2 = str2.split(" ")[0].split("/");

  // year
  if (parseInt(date1[2]) < parseInt(date2[2])) { return true }
  if (parseInt(date1[2]) > parseInt(date2[2])) { return false }
  // month
  if (parseInt(date1[1]) < parseInt(date2[1])) { return true }
  if (parseInt(date1[1]) > parseInt(date2[1])) { return false }
  // day
  if (parseInt(date1[0]) < parseInt(date2[0])) { return true }
  if (parseInt(date1[0]) > parseInt(date2[0])) { return false }

  var time1 = str1.split(" ")[1].split(":");
  var time2 = str2.split(" ")[1].split(":");

  // hours
  if (parseInt(time1[0]) < parseInt(time2[0])) { return true }
  if (parseInt(time1[0]) > parseInt(time2[0])) { return false }
  // minutes
  if (parseInt(time1[1]) < parseInt(time2[1])) { return true }
  if (parseInt(time1[1]) > parseInt(time2[1])) { return false }
  // seconds
  if (parseInt(time1[2]) < parseInt(time2[2])) { return true }
  if (parseInt(time1[2]) > parseInt(time2[2])) { return false }
  return false
};


Vue.use(VuejQueryMask);
Vue.use(VueResize);


Vue.component("alert", {
  /* for now, commented out, can be used as a tooltip to guide the user through the selection sequence */
  template : `
  <!--<div class="alert alert-info alert-dismissible" role="alert" v-if="is_open">
    <button type="button" class="close" data-dismiss="alert" aria-label="Close" @click="close()">
      <span aria-hidden="true">&times;</span>
    </button>
    {{ message }}
  </div>-->
  `,
  props : ["message"],
  data : function() {
    return {
      is_open : true
    }
  },
  methods : {
    close : function() {
      this.is_open = false;
    }
  }
});


Vue.component("loading-spinner", {
  /* indicates that data is being loaded */
  template : `
  <div class="loading-spinner" role="status" v-if="in_progress"></div>
  `,
  data : function() {
    return {
      store : Store
    }
  },
  computed : {
    in_progress : function() {
      return this.store.status.loading;
    }
  }
});


Vue.component("selection-tabs", {
  /* defines the content in the left column - first stage is showing functions, then calls
    or test cases, then functions, then calls */
  props : ["tree"],
  template : `
    <div class="selection-phases">
      <resize-observer @notify="handleResize" />
      <div class="phase" v-bind:class="{show : show_test_data}">
        <test-data></test-data>
      </div>
      <div class="phase" v-bind:class="{show : show_spec}">
        <machine-function-property :tree="tree"></machine-function-property>
      </div>
      <div class="phase" v-bind:class="{show : show_calls}">
        <function-calls></function-calls>
      </div>
    </div>
  `,
  data : function() {
    return {
      store : Store
    }
  },
  computed : {
    show_test_data : function() {
      return this.store.current_tab == "test-data";
    },
    show_spec : function() {
      return this.store.current_tab == "machine-function-property";
    },
    show_calls : function() {
      return this.store.current_tab == "function-calls";
    }
  },
  mounted : function() {
    /*$(window).scroll(function() {
        clearTimeout(sidebar_scroll_timeout);
        sidebar_scroll_timeout = setTimeout(function() {
            $(".selection-phases").animate({"margin-top": $(window).scrollTop()});
        }, 100);
    });*/
  },
  methods : {
    handleResize : function({ width, height }) {
      var window_width = $(window).width();
      if (window_width <= 991){
        $($(".col-md-9")[0]).width(991);
      }
      else {
        $($(".col-md-9")[0]).width(window_width-width-1);
        $("#code-listing").height(
          $(".panel.panel-success.function-calls").outerHeight() -
          $(".panel.panel-success.code-view").find(".panel-heading").first().outerHeight() -
          $("#specification_listing").outerHeight() - 0.05 * $(".panel.panel-success.function-calls").outerHeight());

      }
    }
  }
});


Vue.component("test-data", {
  /* this panel is only displayed in case any data about test cases is detected in the database
  which indicates that the data refers to the CI
  - tests are displayed by name, only one can be selected
  - in order to make finding the test of interest easier, searching by name is enabled
  */
  template : `
  <div v-if="tests_exist" class="panel panel-success">
    <div class="panel-heading">
      <h3 class="panel-title" id="test-cases-title" @click="showTests=!showTests">Test Cases</h3>
    </div>
    <div class="panel-body">
      <transition name="slide-fade">
      <div v-show="showTests" class="list-group" id="test-cases-list">
        <alert message="Select a test to browse performance data related to it." />
        <div class="list-group-item">
          <input type="text" v-model="filter_string" placeholder="Filter tests..." class="form-control" />
        </div>
        <form>
        <div v-for="(b, index) in filtered_buttons" :key="index" class="list-group-item"
        @click="click_test(b.testname)">
          <input type='radio' :test-id="b.testname" :value="b.testname" v-model="checked_test"
            @click="select_test($event)"/>
          {{b.testname}}
        </div>
        </form>
      </div>
      </transition>
    </div>
  </div>`,
  data() {
    return {
      showTests : true,
      all_names:[],
      filter_string: "",
      all_buttons : [],
      checked_test : null,
      store : Store
    }
  },
  computed : {
    tests_exist : function() {
      return this.store.tests_exist;
    },
    filtered_buttons : function() {
      // use the value of this.filter_string to decide which buttons we should display
      if(this.filter_string != "") {
        var final_list = [];
        for(var i=0; i<this.all_buttons.length; i++) {
          if(this.all_buttons[i].testname.includes(this.filter_string)) {
            final_list.push(this.all_buttons[i]);
          }
        }
        return final_list;
      } else {
        return this.all_buttons;
      }
    }
  },
  methods: {
    select_test : function(e) {
      // get the functions called during executions of the selected test
      // and emit an event that tells the specification-listing component to reload
      var that = this;
      // get the test name from the DOM since reactivity hasn't caught up yet
      test_name = $(e.target).attr("value");
      axios.post("/list_functions_by_tests/", {"names" : [test_name]}).then(function(response) {
        tree = response.data;
        that.$root.$emit('tests-selected', tree);
      });
      Store.selected_tests = [test_name];
      that.store.current_tab = "machine-function-property";
    },
    click_test : function (name) {
      // in case user clicks anywhere inside the div containing the test
      // we want that test to be selected so we generate a click on the radio input element
      $("[test-id="+name+"]").click();
    },
    select_all_tests: function(){
      var is_checked = $("#select-all-tests").prop("checked");
      $("#test-cases-list input:checkbox").prop("checked", is_checked);
      if (is_checked) {
        for(var i=0; i<this.filtered_buttons.length; i++){
          this.checkedTests.push(this.filtered_buttons[i].testname);
        }
      }
      else {
        this.checkedTests = [];
      }
    }
  },
  created(){
    var that = this;
    // get all tests, without a filter
    // for now we'll perform filtering on the client side
    axios.get("/list_tests/").then(function(response){
      //console.log(response.data)
      var test_list = response.data;
      var n = test_list.length;
      var buttons = [];
      var names = [];
      for (var i=0; i<n; i++){
        var dict = {testname: test_list[i][0]}
        buttons.push(dict);
        names.push(dict["testname"]);
      }
      that.store.tests_exist = ( n > 0 );
      if (n>0) {
        that.store.current_tab = "test-data";
        that.$root.$emit("tests-detected");
      } else {
        that.store.current_tab = "machine-function-property";
      }
      that.all_buttons = buttons;
      that.all_names = names;
    })
  }
})


Vue.component("machine-function-property", {
  /* component that contains the list of all specification for which the service was monitored
  at runtime, selecting one results in displaying the calls of the selected function

  function names in the database: machine-module.module.name(:optional_name)
  in case the names of the functions in the database contain the machine name separated by a hyphen,
  the machines' names will be displayed as clickable tabs on the first level, selecting one
  results in displaying the list of the functions that contain the selected machine name
  */
  props: ['tree'],
  template : `
    <div class="panel panel-success machine-function-property">
      <div class="panel-heading">
        <h3 class="panel-title" id="function-title">
            Machine / Function / Query
        </h3>
      </div>
      <div class="panel-body">
        <alert message="Select a query to see relevant calls." />
        <transition name="slide-fade">
        <div class="list-group" id="function-list">
          <p v-if="store.tests_exist"/>
          <p v-if="store.tests_exist">
            <a href="#" @click="previous($event)" style="padding-left: 15px;" class="btn btn-primary">&lt; Back</a>
          </p>
          <div id="function-list-data"></div>
          <div class="tab">
            <button v-for="(value,key) in tree" :class="(key===showTab)? 'tablinks active':'tablinks' "
                @click="selectTab(key)" v-show="key">
                {{key}}
            </button>
          </div>
          <subtree v-for="(value,key) in tree" v-show="(key === showTab)"
            :key="key" :id="key" :content="value">
          </subtree>
        </div>
        </transition>
      </div>
    </div>`,
  data() {
    return {showTab: "", store: Store}
  },
  methods : {
    selectTab: function(selectedTab){
      // selectedTab contains the ID of the tabcontent element which needs to be displayed
      this.showTab = selectedTab;
    },
    previous : function(e) {
      e.preventDefault();
      Store.current_tab = 'test-data';
    }
  },
  mounted() {
    console.log("tree on lhs:");
    console.log(this.tree);
    // all tabs except for the one whose ID is == showTab are hidden
    // store the ID of the first tab so that it gets displayed
    var machine_keys=[];
    for (key in this.tree){
      machine_keys.push(key)
    }
    this.selectTab(machine_keys[0]);
    var that = this;
    this.$root.$on('function-select', function(dict){
      // after selecting a function (specification), hide functions list to make space for calls
      //that.showFunctions = false;
    })
    this.$root.$on('tests-detected', function(){
      //that.showFunctions = false;
    })
    this.$root.$on('tests-selected', function(tree){
      that.tree = tree;
      //that.showFunctions = true;
    })
  }

})


Vue.component("subtree",{
  /*functions are listed as a tree structure, this is the first level within a selected tab*/
  props: ['id', 'content'],
  template:  `
    <div class="tabcontent" :id=this.tabid>
      <subtreelevel :htmlcontent="content" :path="id"> </subtreelevel>
    </div>`,
  data() {
    return { tabid: "tab-" + this.id }
  }
})


Vue.component("subtreelevel", {
  /*recursive component, properties store the following information:
  htmlcontent - function tree based on which the html of the element is built, updated for each level
  path - the path through the function tree to the current element
  panelid, stylepadding - strings which are used to define the header on each level
  keyname - title in the header, taken as a dictionary key on the current tree level

  after adding the header for the current level, iterate through the lower level to repeat the process
  if the subtreelist is empty, this is an indicator that we reached the last level
  - this means it is time to display the specification - the recursion stops here*/
  props: ['htmlcontent', 'path', 'panelid', 'stylepadding', 'keyname'],
  template: `
    <div class="panel panel-default" style="inherit">
      <div v-if="keyname" class="panel-heading">
        <h3 class="panel-title" :id="this.panelid" :style="this.stylepadding" @click=toggleView()>
          {{this.keyname}} </h3>
      </div>
      <div :class="this.show ? 'panel-body show' : 'panel-body'">
        <div class="list-group" :id="path">
          <subtreelevel v-for="(level,index) in this.subtreeslist" :key="index" :htmlcontent="level.nextcontent"
          :path="level.nextpath" :panelid="level.panelid" :stylepadding="level.stylepadding"
          :keyname="level.keyname"></subtreelevel>
          <div v-if="!this.subtreelist">
            <button v-for="(b, index) in this.buttons" type="button" class="list-group-item"
              :function-id="b.functionid" :style="b.padding"
                @click="selectFunction(b.functionid, b.property_hash, b.str)">
              <specification :spec=b.str :change="0"></specification>
            </button>
          </div>
        </div>
      </div>
    </div>
    `,
  data() {
    // take subtree and path from properties parsed to this component
    var subtree = JSON.parse(JSON.stringify(this.htmlcontent));
    var path = this.path;
    var padding = String(path.split("-").length * 20) + "px";

    // check if the last level is reached - if it is, return an empty subtrees list to indicate this
    // also return the HTML needed to build the element with the specification
    if(Array.isArray(subtree)) {
      var buttons = [];
      for(var i=0; i<subtree.length; i++) {
        var str = subtree[i][2];
        //str = decodeHTML(str);
        buttons.push({
          functionid: subtree[i][0],
          padding : "padding-left:" + padding,
          str : str,
          property_hash : subtree[i][1]
        });
      }
      return {
        buttons: buttons,
        subtreeslist:[],
        store : Store,
        show : true
      }

    // if this is not the last level, iterate through the keys in the subtree and return the list
    // based on which new subtree components will be defined
    } else {
      var keys = [];
      for (var key in subtree) {
        keys.push(key);
      }
      //console.log("path="+path+"; keys="+ keys);

      var dicts_list = [];
      for(var i=0; i<keys.length; i++) {
        var key = keys[i];
        // create list inside the current list in the dom
        var new_path = (path != "") ? (path + "-" + key) : key;
        var panel_id = "external-" + new_path;
        var style_padding = "padding-left: " + padding;

        dicts_list.push({keyname: key,
          nextcontent : subtree[key], nextpath : new_path,
          stylepadding : style_padding, panelid : panel_id});
      }
      return {subtreeslist : dicts_list, show : true}
    }
  },
  methods : {
    selectFunction: function(id, property_hash, code){

      start_loading();

      // switch to the tab showing the list of calls
      this.store.current_tab = 'function-calls';

      path_highlight_mode_on = false;

      this.store.selected_property_hash = property_hash;
      this.store.selected_function_id = id;
      this.$root.$emit(
        'function-select',
        {
          selected_function_id: id,
          specification_code: code,
          property_hash: property_hash
        }
      );
    },
    toggleView: function(){
      this.show = !this.show;
    }
  }
})


Vue.component("function-calls", {
  /*this panel is displayed on the left side upon the seletion of a monitored function
  displays the list of the calls of the selected function, and a select all option, as well as
  the option to select calls by specifying a time interval

  the selected calls are stored in the checkedCalls array which is being watched and every change
  to this array updates the data displayed on the right side to match the new selection*/
  template : `
    <div class="panel panel-success function-calls">
      <div class="panel-heading">
        <h3 class="panel-title" id="function-call-title">Function Calls</h3>
      </div>
      <div class="panel-body">
        <div class="list-group" id="function-call-list" @click="date_input_error=false">
          <div v-if="message" class="please-select"><p>{{message}}</p></div>
          <alert v-if="!message" message="Select one or more calls to load performance data." />
          <div v-if="!message" class="list-group-item">
            <p><a href="#" @click="previous($event)" class="btn btn-primary">&lt; Back</a></p>
            <form class="form-inline" action="">
            <b>From</b> <vue-mask id="filter-from" v-model="filter_from" mask="00/00/0000 00:00:00"
                         placeholder="DD/MM/YYYY hh:mm:ss" :raw="false" class="form-control"> </vue-mask> <br>
            <b>To &nbsp;&nbsp;&nbsp; </b> <vue-mask id="filter-to" v-model="filter_to" mask="00/00/0000 00:00:00"
                       placeholder="DD/MM/YYYY hh:mm:ss" :raw="false" class="form-control"> </vue-mask>
            <div class="tooltip-alert" v-show="date_input_error"> Wrong datetime input.</div>
            <button @click="select_filtered($event)" class="btn btn-default"> Filter calls </button>
            </form>
          </div>
          <button v-if="!message" class="list-group-item" @click="toggleSelection(-1,-1)">
            <input type='checkbox' id="select-all-calls" @click="select_all_calls($event)"/><b> Select all </b>
          </button>
          <button v-for="(b, index) in this.buttons" :key="index" class="list-group-item"
                  @click="toggleSelection(index, b.callid)">
            <input type='checkbox' :function-call-id="b.callid" :value="b.callid" v-model="checkedCalls"
            @click="($event).stopPropagation()"/>
            {{b.callstart}}
            <span v-if="tests_exist" class="badge" v-bind:class="b.testresult">unit test</span>
            <span class="badge" v-bind:class="translate_verdict(b.verdict)">query</span>
            <span class="badge">lasted {{b.callduration}} seconds</span>
          </button>
        </div>
      </div>
    </div>`,
  data() {
    return {
      message : "Select a function first.",
      buttons : [],
      checkedCalls: [],
      filter_from: "",
      filter_to: "",
      func_id: 0,
      date_input_error: false,
      store : Store}
  },
  computed : {
    tests_exist : function() {
      return this.store.tests_exist;
    }
  },
  methods: {
    previous : function(e) {
      e.preventDefault();
      this.store.current_tab = 'machine-function-property';
    },
    translate_verdict : function(v) {
      if(v == 1) return "Success";
      else return "Violation";
    },
    select_all_calls: function(e = null){
      start_loading();
      var is_checked = $("#select-all-calls").prop("checked");
      $("#function-call-list input:checkbox").prop("checked", is_checked);
      if (is_checked) {
        for(var i=0; i<this.buttons.length; i++){
          this.checkedCalls.push(this.buttons[i].callid);
        }
      }
      else {
        this.checkedCalls = [];
      }
      // display only relevant alerts
      Store.binding_selected = false;
      Store.subatom_selected = false;

      stop_loading();
      if (e) {e.stopPropagation();}

    },
    select_filtered: function(e){
      e.preventDefault();

      if(is_before(this.filter_to, this.filter_from)) {
        // in case the time entered in 'from' is after the time in 'to', show an alert
        this.date_input_error = true;
      }

      start_loading();

      $("#function-call-list input:checkbox").prop("checked", false);
      this.checkedCalls = [];
      var time = {function: this.func_id, from: this.filter_from, to: this.filter_to,
                  tests: Store.selected_tests};
      var that = this;

      axios.post("/list_calls_between/", time).then(function(response){
        var ids_list = response.data;
        var calls_list = $("#function-call-list input:checkbox");
        for (var i=0; i<that.buttons.length; i++){
          if (that.buttons[i].callid == ids_list[0]){
            for (var j=i; j<i+ids_list.length; j++){
              that.checkedCalls.push(that.buttons[j].callid);
              // select all is the first input:checkbox in the f-call-list, hence j+1
              $(calls_list[j+1]).prop("checked", true);
            }
            break
          }
        }
      })
      stop_loading();
      e.stopPropagation();
      // prevents closing the error message when clicking 'filter calls'
      // - this is the button that makes the error appear, so it would cancel the effect
    },
    toggleSelection: function(n, call_id) {
      // in case click happened outside the checkbox, but within a call button
      var input_box = $("#function-call-list input:checkbox")[n+1];
      var selected = $(input_box).prop("checked");
      $(input_box).prop("checked", !selected);
      if (call_id == -1) {
        //indicator argument which tells us method was called by select all button
        this.select_all_calls();
      }
      else {
        if (selected) {
          this.checkedCalls.splice(this.checkedCalls.indexOf(call_id), 1);
        }
        else{
          this.checkedCalls.push(call_id);
        }
      }
    }
  },
  mounted(){
    var that = this;
    this.$root.$on('tests-selected', function(tree){
      that.message = "Select a function first.";
      that.buttons = [];
      that.checkedCalls = [];
      that.filter_from = "";
      that.filter_to = "";
      that.func_id = 0;
      that.store = Store;
    })
    this.$root.$on('function-select', function(dict){
      // when a specification is selected, get the calls list from server
      // while it's loading, display a temporary message
      // since each call has an input checkbox, we need to catch any changes in the selection

      that.message = "Loading function calls.  This can take some time if there are many.";
      that.buttons = [];
      that.checkedCalls = [];
      that.func_id = dict["selected_function_id"];

      axios.post(
        '/list_function_calls/',
        {
          function: that.func_id,
          tests: Store.selected_tests
        }
      ).then(function(response){
        var data = response.data["data"];
        that.message = "";
        var buttons_list = [];
        var i;
        for(i=0; i<data.length; i++) {
          var button = {
            callid : data[i][0],
            callstart: data[i][2],
            callduration: data[i][6],
            verdict: data[i][7],
            testresult: that.store.tests_exist ? data[i][8] : null
          }
          buttons_list.push(button)
        }
        that.buttons = buttons_list;
        that.filter_from = buttons_list[0].callstart;
        that.filter_to = buttons_list[i-1].callstart;

        that.$root.$emit('calls-loaded', dict);
      })
    })
  },
  watch: {
    checkedCalls: function(value){
      var function_call_ids = [];
      var that = this;
      for (var i=0; i<value.length; i++){
        function_call_ids.push(""+value[i]);
      }

      Store.selected_calls = function_call_ids;
      if (!plot_visible) {
        // display code interface
        if (function_call_ids.length){
          axios.post(
            "/get_function_calls_data/",
            {
              "ids" : function_call_ids,
              "property_hash" : Store.selected_property_hash
            }
          ).then(function(response) {
            tree = response.data;
            that.$root.$emit('calls-selected',tree);
          });
        }
      } else {
        // add data to plot without displaying code interface
        plot_data.calls = function_call_ids;
        // trigger plotting - since plots are opened in a separate window, we don't
        // do this for now
        //generate_plot(this);
      }
    }
  }
})


Vue.component("code-view", {
  /* This is the most complex component. It is empty at the beginning, but upon the selection
  of the function and the calls, some data is displayed. When the user selects a function,
  the specification and the source code of the selected function are shown. Additionally,
  the lines in the code that quantifiers in the specification refer to are highlighted.
  When the calls are also selected, more data is displayed and some code lines are hidden.
  As we progress through the selection sequence, the displayed data is updated to match the
  filtered data.*/
  template : `
    <div class="panel panel-success code-view">
      <div class="panel-heading">
        <h3 class="panel-title">Code View</h3>
      </div>
      <div class="panel-body" id="verdict-list">
        <div v-if="message" class="please-select">{{message}}</div>
        <alert v-if="binding_is_selected"
            message="Select a part of the query to narrow down critical statements in the code." />
        <div v-if="specification_code" id='specification_listing'>
          <specification :spec="this.specification_code" :change="1" />
        </div>
        <div v-if="code_lines" class='code_listing' id="code-listing">
          <div v-if="code_error" class="alert alert-danger" role="alert">
            <strong>Error: </strong>{{code_error}}
          </div>
          <div v-if="no_paths" class="alert alert-info" role="alert">
            {{no_paths}}
          </div>
          <alert v-if="calls_are_selected" message="Select a binding in the code listing below." />
          <alert v-if="subatom_is_selected" message="Hover over a critical statement to see analysis options." />
          <div v-for="(line,index) in code_lines" :key="index" :class="line.class"
          :id="line.id" :style="line.background" :save-background-color="line.color"
          v-show="show_line(line.show)">
            <span class="line-number"> {{line.line_number}} </span>
            <span class="language-python" v-html="line.content"> </span>
            <span v-if="line.addmenu"><a href="#" class="badge options" @click="toggle_menu($event)">options</a></span>
            <span class="span-binding" :id="line.spanid">
            <button v-for="b in line.buttons"
            class="binding-button" :binding-button="b.binding" :style="b.font"
            @click="selectBinding(b.binding, b.subtree, b.lines)">binding {{b.binding}}</button>
            </span>
            <p v-show="show_empty_line_marker(line.showempty)" class="empty-line" :id="line.emptyid"><b> ... </b><br> </p>
            <dropdown v-if="line.addmenu" :tree="this.tree" :dict="line.dict" :binding="this.binding"
            :line=line.line_number @firstselected="selectOther($event)"> </dropdown>
          </div>
        </div>
      </div>
    </div>`,
  data(){
    return {
      message: "Select a function and then one or more calls, first.",
      code_error: false,
      no_paths: false,
      specification_code: "",
      code_lines: [],
      start_line: 0,
      tree: {},
      binding: undefined,
      store : Store}
  },
  computed : {
    calls_are_selected : function() {
      return this.store.selected_calls.length > 0;
    },
    binding_is_selected : function() {
      return this.store.binding_selected;
    },
    subatom_is_selected : function() {
      return this.store.subatom_selected;
    }
  },
  methods : {
    show_line : function(line_show_flag) {
      return line_show_flag || path_highlight_mode_on;
    },
    show_empty_line_marker : function(line_show_flag) {
      return !path_highlight_mode_on && line_show_flag;
    },
    toggle_menu : function(e) {
      e.preventDefault();
      $(e.target).parent().parent().find(".dropdown-content").slideToggle();
      $(e.target).toggleClass("active");
    },
    selectBinding : function(binding, tree, lines){
      // binding stores the index of the binding, tree is the branch tree[binding]
      // lines is a list of line numbers that need to be highlighted

      var whole_code = this.code_lines;
      var start_line = this.start_line;

      // reset the first point selection that affects the dropdown menu
      Store.first_point_selected = false;
      // remove alert-info about just one path
      this.no_paths = false;
      // reset the background colors of previously highlighted lines
      for (var i=0; i<whole_code.length; i++){
        var line = whole_code[i];
        line.addmenu = false;
        line.class = "code_listing_line";
        if (line.color){
          line.background = "background-color: #ebf2ee";
        }
        else {
          whole_code[i].background = "background-color: transparent";
        }
        for (var j=0; j<line.buttons.length; j++){
          if (line.buttons[j].binding == binding){
            line.buttons[j].font = "font-weight: bold";
          }
          else{
            line.buttons[j].font = "font-weight: normal";
          }
        }
      }

      for (var i=0; i<lines.length; i++){
        var line = whole_code[lines[i]-start_line];
        line.background = "background-color: " + line.color;
      }
      this.binding = binding;
      selected_binding = binding;
      this.tree = tree;
      this.store.path_view = false;
      this.$root.$emit("binding-selected", tree);
    },
    selectOther : function(list){
      // called when the second point in a pair is selected (mixed atoms)
      // remove previous menus
      for (var i=0; i<this.code_lines.length; i++){
        this.code_lines[i].addmenu = false;
      }

      // add menus to the points in the given list - options handled in dropdown component
      for (var i=0; i<list.length; i++){
        var index = list[i]["line"]-this.start_line;
        var line = this.code_lines[index];

        line.background = "background-color: " + line.color;
        line.addmenu = true;
        line.class = "code_listing_line code_listing_line-clickable";
      }
    }
  },
  mounted(){
    var that = this;
    $("#code-listing").height(
      $(".panel.panel-success.function-calls").outerHeight() -
      $(".panel.panel-success.code-view").find(".panel-heading").first().outerHeight() -
      $("#specification_listing").outerHeight());
    this.$root.$on('tests-selected', function(tree){
      // if there are test cases, when one is selected, in case code data was displayed before
      // reset the code view - the specification and calls selection will reload the appropriate content
      that.message = "Select a function and then one or more calls, first.";
      that.specification_code = "";
      that.code_lines = [];
      that.start_line = 0;
      that.tree = {};
      that.binding = undefined;
      that.store = Store;
      that.no_paths = false;
    })
    this.$root.$on('calls-loaded', function(dict){
      // when a function is selected, calls are loaded and the entire code is displayed
      // quantifiers and corresponding lines are paired by colour-coded highlighting
      start_loading();

      // reset values
      path_highlight_mode_on = false;
      that.message = "";
      that.specification_code = dict["specification_code"];
      that.no_paths = false;

      axios.get('/get_source_code/'+dict["selected_function_id"]).then(function(response){
        var code_data = response.data;
        if (code_data["error"]){
          that.code_error = code_data["error"];
          stop_loading()
        }
        var code_lines = code_data["code"];
        var current_line = code_data["start_line"];
        that.start_line = current_line;

        // we also want to display binding reference at the end of each line
        // first, go through bindings and collect all line numbers they refer to
        var bindings_list = code_data["bindings"];
        var line_numbers = [];
        for (var i=0; i<bindings_list.length; i++){
          binding = bindings_list[i];
          line_numbers = line_numbers.concat(binding["binding_statement_lines"]);
        }

        // add each line as a div element, if it is in the list of binding statement lines,
        // also add a span element to the content of the line - later, we will add binding labels to it
        var lines_list = [];
        for(var i=0; i < code_lines.length; i++) {
          code_lines[i] = hljs.highlight("python", code_lines[i]).value;
          var line_text = code_lines[i].replace(/\t/g, "&nbsp;&nbsp;&nbsp;").replace(/^[ \t]+/mg, html_space_replace);
          var line_div = {line_number: current_line, id: "line-number-" + current_line,
                          background: "background-color: transparent", color: "", show: true,
                          added_empty_line: false, spanid: "span-bindings-line-" + current_line,
                          content: line_text, buttons: [], emptyid: "empty-line-" + current_line,
                          showempty: false, addmenu: false, class: "code_listing_line", dict: {}}


          lines_list.push(line_div);
          current_line++;
        }

        that.code_lines = lines_list;


        // we want to highlight the quantification in the specification code
        // with the same color as the line of code it refers to
        var quantification_ids = that.specification_code["vars"].split(", ");

        // for each binding line go through the specification to find the quantification
        // that refers to that line and highlight it the same color as the line in the code
        for (var i=0; i<bindings_list.length; i++){
          var binding = bindings_list[i];
          var line_numbers = binding["binding_statement_lines"];

          for (var j=0; j<line_numbers.length; j++){
            var no = line_numbers[j]
            var color = code_highlight_palette[j];
            lines_list[no-code_data["start_line"]].background = "background-color: "+color;
            lines_list[no-code_data["start_line"]].color = color;
            //$("#span-bindings-line-"+no).append(" "+binding["id"]);
          } //end j-loop
        } //end i-loop

        stop_loading();
      })
    })
    this.$root.$on('calls-selected', function(tree){
      // when calls are selected, code view is adjusted to display the points of interest for those calls
      that.tree = tree;
      path_highlight_mode_on = false;

      var show_lines = []; //stores all lines that are of interest plus a few around them - we will hide the rest
      var start_line = that.start_line;
      var whole_code = that.code_lines;

      //clean up the binding buttons and dropdown menus from previous selection
      for (var i=0; i<whole_code.length; i++){
        whole_code[i].buttons = [];
        whole_code[i].addmenu = false;
        whole_code[i].class = "code_listing_line";
        whole_code[i].background = "background-color: transparent";
      }
      that.store.path_view = false;
      that.no_paths = false;


      // iterate through the bindings to highlight the lines and separate those paired with
      // a quantifier from those that are of interest because a subatom generates observations there
      for (binding in tree){
        var line_numbers = []; //stores all points of interest
        var lines_points = []; //stores only those stored by bindings
        for (atom in tree[binding]){
          for (subatom in tree[binding][atom]){
            list = tree[binding][atom][subatom];
            for (var i=0; i<list.length; i++){
              if (line_numbers.indexOf(list[i]["code_line"])==-1){
                line_numbers.push(list[i]["code_line"]);
              }
              if (atom=="-1" && lines_points.indexOf(list[i]["code_line"])==-1){
                lines_points.push(list[i]["code_line"]);
              }

            }
          }
        }
        show_lines = show_lines.concat(line_numbers);
        for (var i=0; i<line_numbers.length; i++){
          var no = line_numbers[i] - that.start_line;
          whole_code[no].background = "background-color: #ebf2ee"
          color = whole_code[no].color;
          if (!(color)){
            whole_code[no].color = "#def1fc";
          }
        }
        for (var i=0; i<lines_points.length; i++){
          var no = lines_points[i];
          whole_code[no-start_line].buttons.push({binding: binding, subtree: tree[binding],
            lines: line_numbers, font: "font-weight: normal"});
          }
        }

      show_lines = show_lines.sort(function(a, b){return a - b});

      //in addition to the lines stored in leaves, we want to display the first line
      // and in this case, three lines around each instrumentation point
      var more_lines = [that.start_line];
      for (var i=0; i<show_lines.length; i++){
        var current_line_number = show_lines[i];
        if (current_line_number - 1 <= that.start_line) {
          more_lines.push(current_line_number + 1);
          more_lines.push(current_line_number + 2);
          continue
        }
        if (current_line_number >= that.start_line + whole_code.length - 2) {
          more_lines.push(current_line_number - 1);
          more_lines.push(current_line_number - 2);
          if (current_line_number == that.start_line + whole_code.length - 2) {
            more_lines.push(current_line_number + 1);
          }
          continue
        }
        for (var j=1; j<3; j++){
          more_lines.push(current_line_number+j);
          more_lines.push(current_line_number-j);
        }
      }
      show_lines = show_lines.concat(more_lines);

      // go through the code and set 'show' paramater of each line to 'true' if it's in show_lines
      for (var i=0; i<whole_code.length; i++){
        var line_id = whole_code[i].id.split("-");
        var id_line_number = line_id[line_id.length-1];
        if (show_lines.indexOf(parseInt(id_line_number))==-1){
          whole_code[i].show = false;
        }
        else{
          whole_code[i].show = true;
        }
      }

      // insert a spacing where there is a jump in line numbers
      show_lines = show_lines.sort(function(a, b){return a - b});

      for (var i=0; i<show_lines.length; i++){
        if (show_lines[i] < (show_lines[i+1] - 1)){
          whole_code[show_lines[i]-that.start_line].showempty = true;
        }
        else{
          whole_code[show_lines[i]-that.start_line].showempty = false;
        }
      }
    })
    this.$root.$on("subatom-selected", function(dict){
      /* For selected calls, binding, and subatom, highlight the lines that represent
      instrumentation points monitored during those calls and at which observation were
      generated by the selected subatom. In addition to highlighing those lines, we also want
      to be able to select them as instrumentation point and fetch some data about the
      corresponding observations and verdicts in order to visualise the performance analysis results.
      The visualisation options are given within a dropdown menu.
      */
      var atom_index = dict["atom"];
      var sub_index = dict["subatom"];
      var inst_points_list = that.tree[atom_index][sub_index];
      var whole_code = that.code_lines;

      var lines_list = [];
      for (var i=0; i<inst_points_list.length; i++){
        var no = inst_points_list[i]["code_line"];
        //$("#line-number-"+no).attr('save-background-color',color);
        lines_list.push(no);
      }

      // clean up any previous dropdowns and reset highlights back to a light colour
      // reset the class of the line back to non-clickable
      that.store.path_view = false;
      that.no_paths = false;
      for (var i=0; i<whole_code.length; i++){
        if (whole_code[i].color) {
          whole_code[i].background = "background-color: #ebf2ee";
          whole_code[i].addmenu = false;
          whole_code[i].class = "code_listing_line";
        }
        else {
          whole_code[i].addmenu = false;
          whole_code[i].background = "background-color: transparent";
        }
      }

      // now highlight and add dropdowns to the lines in lines_list
      for (var i=0; i<lines_list.length; i++){
        var line = whole_code[lines_list[i]-that.start_line]
        line.background = "background-color: " + line.color;
        line.dict = dict;
        line.addmenu = true;
        line.class = "code_listing_line code_listing_line-clickable";
      }
    })
    this.$root.$on('path-data-ready', function(data_ready){
      // use data prepared by highlight_paths function to edit the code

      var whole_code = that.code_lines;
      console.log(data_ready);
      var start = that.start_line;

      if (data_ready["lines_to_colors"].length == 0) {
        that.no_paths = "All the runs took the same path - analysis by path unavailable."
      }

      // path differences - colours by severity
      for (var i=0; i<data_ready["lines_to_colors"].length; i++) {
        var dict = data_ready["lines_to_colors"][i];
        for (var j=0; j<dict["lines"].length; j++) {
          whole_code[dict["lines"][j]-start].background = "background-color: " + dict["color"];
        }
      }

      // path intersection - highlight but without indicating severity
      for (var i=0; i<data_ready["main_lines"].length; i++) {
        whole_code[data_ready["main_lines"][i]-start].background = "background-color: #cce0ff";
      }


      that.store.path_view = true;

      console.log("highlighting parameters");
      console.log(data_ready["parameter_lines"]);

      // add menu to e.g. a branching point that offers analysis by path options
      for (var i=0; i<data_ready["parameter_lines"].length; i++) {
        whole_code[data_ready["parameter_lines"][i]-start].background = "background-color: lightgrey";
        whole_code[data_ready["parameter_lines"][i]-start].dict = "PATH";
        whole_code[data_ready["parameter_lines"][i]-start].addmenu = true;

      }

      that.code_lines = whole_code;
      //$("#path-wrapper").addClass("show");

    })
  }
})


Vue.component("specification", {
  /* this component is still jquery reliant as a part of its HTML (atom and subatom span elements)
  is received from the server side instead of being generated within the template*/
  props: ['spec', 'change'],
  template: `
    <div>
      <p v-for="(v, index) in this.bindvars"><span class="list-group-item-text code" :id="v.id" v-html="v.forall"
          :style="v.background"> </span></p>
      <div class="inner-part">
        <p><span class="list-group-item-text code">Check( </span></p>
        <p><span class="list-group-item-text code" v-html="this.vars"></span></p>
        <p><span class="list-group-item-text code" v-html="this.str"></span></p>
        <p><span class="list-group-item-text code">&nbsp;&nbsp;) </span></p>
        <p><span class="list-group-item-text code">)</span></p>
      </div>
    </div>`,
  data(){
    var spec_dict = this.spec;
    var list = spec_dict["foralls"];
    var bindvars = [];
    for (i=0; i<list.length; i++){
      var bg;
      if (this.change==1){
        bg = "background-color: " +
          code_highlight_palette[spec_dict["vars"].split(", ").indexOf(list[i]["var_id"])] + ";";
      }
      else{
        bg = "background-color: transparent;";
      }
      bindvars.push({id: list[i]["var_id"],
                     forall: "Forall("+list[i]["var_forall"]+").\\ ",
                     background: bg})
    }
    return {
      vars : "&nbsp;&nbsp;lambda " + spec_dict["vars"] + " : (",
      str : "&nbsp;&nbsp;&nbsp;&nbsp; " + spec_dict["atom_str"],
      bindvars: bindvars
    }
  },
  watch: {
    // when a new specification is selected, the specification listing in the code view component
    // must also change - watch for this change and change the data to trigger the rerendering
    spec(newValue) {
      var spec_dict = newValue;
      var list = spec_dict["foralls"];
      var bindvars = [];
      for (i=0; i<list.length; i++){
        var bg;
        if (this.change==1){ bg = "background-color: " +
            code_highlight_palette[spec_dict["vars"].split(", ").indexOf(list[i]["var_id"])] + ";";}
        else { bg = "background-color: transparent;";}
        bindvars.push({id: list[i]["var_id"],
                       forall: "Forall("+list[i]["var_forall"]+").\\ ",
                       background: bg})
      }
      this.vars = "&nbsp;&nbsp;lambda  : ( " + spec_dict["vars"];
      this.str = "&nbsp;&nbsp;&nbsp;&nbsp; " + spec_dict["atom_str"];
      this.bindvars = bindvars;
    }
  },
  mounted(){
    var that = this;
    this.$root.$on('calls-loaded', function(tree){
      // clean up subatom links from previous function selection
      remove_subatoms = $(".subatom-clickable");
      if (typeof(remove_subatoms) != 'string'){
      for (var i=0; i<remove_subatoms.length; i++){
        $(remove_subatoms[i]).attr("onclick", "");
        $(remove_subatoms[i]).attr('class', "subatom");
      }}
      $($(".subatom-clickable-active")[0]).attr("onclick","");
      $($(".subatom-clickable-active")[0]).attr("class", "subatom");
    })

    this.$root.$on('calls-selected', function(tree){
      // clean up subatom links from previous binding selection
      remove_subatoms = $(".subatom-clickable");
      if (typeof(remove_subatoms) != 'string'){
      for (var i=0; i<remove_subatoms.length; i++){
        $(remove_subatoms[i]).attr("onclick", "");
        $(remove_subatoms[i]).attr('class', "subatom");
      }}
      $($(".subatom-clickable-active")[0]).attr("onclick","");
      $($(".subatom-clickable-active")[0]).attr("class", "subatom");
    })

    this.$root.$on('binding-selected', function(tree){
      Store.binding_selected = true;
      path_highlight_mode_on = false;
      // clean up subatom links from previous binding selection
      remove_subatoms = $(".subatom-clickable");
      if (typeof(remove_subatoms) != 'string'){
      for (var i=0; i<remove_subatoms.length; i++){
        $(remove_subatoms[i]).attr("onclick", "");
        $(remove_subatoms[i]).attr('class', "subatom");
      }}
      $($(".subatom-clickable-active")[0]).attr("onclick","");
      $($(".subatom-clickable-active")[0]).attr("class", "subatom");

      // highlight the atoms that generated observations for the selected calls and binding
      // make subatoms clickable - global function subatom_click() will then emit event
      // so that other components can react to the subatom selection
      for (atom in tree){
        var subtree = tree[atom];
        var subs = $($("#specification_listing").find('span.atom[atom-index="' + atom + '"]')[0]).find("span.subatom");
        for (var i=0; i<subs.length; i++){
          $(subs[i]).attr('class', "subatom-clickable");
          $(subs[i]).attr('subtree', JSON.stringify(subtree));
          var dict = {atom: atom, subatom: $(subs[i]).attr("subatom-index")};
          $(subs[i]).attr('onclick', 'subatom_click('+JSON.stringify(dict)+')');
        }
      }
    })

    this.$root.$on("subatom-selected", function(dict){
      path_highlight_mode_on = false;
      // when a subatom is selected, change its class to active - this affects its style
      $($(".subatom-clickable-active")[0]).attr("class", "subatom-clickable");
      var subatom = $(
        $("#specification_listing").find('span.atom[atom-index="' + dict["atom"] + '"]'
      )[0]).find(
        'span[subatom-index="'+dict["subatom"]+'"]'
      )[0];
      $(subatom).attr("class", "subatom-clickable-active");
      // update global state
      Store.plot.constraint_html = decodeHTML($($(".subatom-clickable-active")[0]).parent().html());
      Store.subatom_selected = true;
    })
  }
})


Vue.component("dropdown", {
  /* is displayed when hovering above the corresponding line in the code
   requires data about all the previously selected levels in order to get the filtered verdict
   and observation values from the server */
  props: ["tree", "dict", "binding", "line"],
  template: `
    <div class="dropdown-content">
      <p v-for="option in this.options" class="dropdown-menu-option" @click="selectOption(option.data)">
        {{option.text}} </p>
    </div>
  `,
  data(){
    // menu generated by branching statement should give options for plotting wrt paths taken
    // this case can be recognised as dict will be "PATH"
    if (this.dict == "PATH") {
      var atom_type = Store.plot.type.split("-")[0];
      return {options: [{text: "Plot observations with regards to paths taken",
                         data: {action: atom_type + "-path-plot",
                                type: atom_type + "-path-observation"}
                       },
                        {text: "Plot verdict severity with regards to paths taken",
                         data: {action: atom_type + "-path-plot",
                                type: atom_type + "-path-severity"}}
                       ]
             }
    }


    // indicator variable tells if  the menu is a child of a line selected as
    // the second one in a pair (timeBetween/mixed atom)

    if (Store.first_point_selected){
      var new_list = [];
      var between_or_mixed = Store.plot.type;
      for (var i=0; i<plot_data["other_lines"].length; i++){
        if (plot_data["other_lines"][i]["line"] == this.line){
          new_list.push(plot_data["other_lines"][i]["id"]);
        }
      }
      return {options: [{text: "Select this statement and plot observations",
                         data: {action: between_or_mixed + "-observation-plot",
                                type : between_or_mixed + "-observation",
                                new_points: new_list}},
                        {text: "Select this statement and plot severity",
                         data: {action: between_or_mixed + "-severity-plot",
                                type : between_or_mixed + "-severity",
                                new_points: new_list}},
                        {text: "Select this statement and highlight paths by severity",
                         data: {action: between_or_mixed + "-path",
                                type : between_or_mixed + "-path",
                                new_points: new_list}}]}
    }

    // if first_point_selected is false, proceed as if the dropdown is generated
    // to select the first point

    var options = [];
    var atom_index = this.dict["atom"];
    var sub_index = this.dict["subatom"];
    var inst_points = this.tree[selected_binding][atom_index][sub_index];
    var inst_point_id = inst_points[0]["id"];
    var that = this;

    var inst_points_list = [];
    for (var i=0; i<inst_points.length; i++){
      if (inst_points[i]["code_line"] == this.line){
        inst_points_list.push(inst_points[i]["id"]);
      }
    }

    // the options in the menu depend on the type of the atom that contains the selected subatom

    axios.get('/get_atom_type/'+atom_index+"/"+inst_point_id+"/").then(function(response){
      var atom_type = response.data;
      //console.log(atom_type);
      Store.type_of_atom = atom_type;
      if (atom_type == "simple"){
        //for a simple atom we now need all observations made at these points,
        //filtered by: calls, binding, atom, subatom
        //then we can calculate verdict severity for each of the observations
        var option = {text: 'Plot severity of observations from this point',
                      data: {action: "simple-severity-plot",
                             type : "severity",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option);
         var option = {text: 'Plot observations from this point',
                      data: {action: "simple-observation-plot",
                             type : "observation",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option);
        var option2 = {text: 'Highlight paths by average verdict severity',
                      data: {action: "simple-path",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option2);
      }
      else if (atom_type == "timeBetween" || atom_type == "mixed") {
        // we need the list of inst points that belong to the same atom, but other than the selected subatom
        var other_points_list = [];
        var subtree = that.tree[selected_binding][atom_index];
        for (subatom in subtree){
          if (subatom != sub_index){
            for (var i=0; i<subtree[subatom].length; i++){
              other_points_list.push({id: subtree[subatom][i]["id"],
                                      line: subtree[subatom][i]["code_line"]});
            }
          }
        }
        option = {text: 'Select this statement and highlight others that can form a pair',
                  data: {action: (atom_type=="timeBetween") ? "between-select" : "mixed-select",
                         type : (atom_type=="timeBetween") ? "between-select" : "mixed-select",
                         other_lines: other_points_list,
                         calls: Store.selected_calls,
                         binding: selected_binding,
                         atom: atom_index,
                         points: inst_points_list,
                         selected_line_numbers: [that.line]}};
        options.push(option);
      }
    })
    var return_data = {options: options};
    return return_data
  },
  methods: {
    selectOption: function(data){
      /* an option was clicked, depending on which one it was and for which atom type, proceed
      by either adding menu to another line in the code or invoking functions that fetch the data
      about plots/pahts from the server side

      every option stores all the data required in order to know how to proceed in the 'data' prop
      which also contains information that needs to be sent to the server side
      'action' is the string that indicates what needs to be done next
      */
      start_loading();
      if (data["action"] == "simple-severity-plot"){
        // set the plot data globally
        plot_data = data;
        // set the plot type
        Store.plot.type = "severity";
        // plot the data we just set
        generate_plot(this);
      }
      if (data["action"] == "simple-observation-plot"){
        // set the plot data globally
        plot_data = data;
        // set the plot type
        Store.plot.type = "observation";
        // plot the data we just set
        generate_plot(this);
      }
      if (data["action"] == "simple-path") {
        plot_data = data;
        plot_data["function_id"] = Store.selected_function_id;
        plot_data["type"] = "simple-path";
        Store.plot.type = "simple-path";
        path_highlight_mode_on = true;
        highlight_paths(this);
      }
      if (data["action"] == "between-select" || data["action"] == "mixed-select") {
        plot_data = data;
        Store.first_point_selected = true;
        Store.plot.type = data["action"].split("-")[0];
        var new_list = [];
        var between_or_mixed = Store.plot.type;
        for (var i=0; i<plot_data["other_lines"].length; i++){
          if (plot_data["other_lines"][i]["line"] == this.line){
            new_list.push(plot_data["other_lines"][i]["id"]);
          }
        }
        this.options = [{text: "Fix this point as the other one and plot observations",
                         data: {action: between_or_mixed + "-observation-plot",
                                  type : between_or_mixed + "-observation",
                                  new_points: new_list}},
                         {text: "Fix this point as the other one and plot severity",
                          data: {action: between_or_mixed + "-severity-plot",
                                  type : between_or_mixed + "-severity",
                                  new_points: new_list}},
                         {text: "Fix this point as the other one and highlight paths by severity",
                          data: {action: between_or_mixed + "-path",
                                 type : between_or_mixed + "-path",
                                 new_points: new_list}}];
        this.$emit("firstselected", data["other_lines"]);
      }
      else if (data["action"] == "between-observation-plot") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "between-observation";
        Store.plot.type = "between-observation";
        generate_plot(this);
      }
      else if (data["action"] == "between-severity-plot") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "between-severity";
        Store.plot.type = "between-severity";
        generate_plot(this);
      }
      else if (data["action"] == "mixed-observation-plot") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "mixed-observation";
        Store.plot.type = "mixed-observation";
        generate_plot(this);
      }
      else if (data["action"] == "mixed-severity-plot") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "mixed-severity";
        Store.plot.type = "mixed-severity";
        generate_plot(this);
      }
      else if (data["action"] == "between-path") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "between-path";
        plot_data["selected_line_numbers"].push(this.line);
        plot_data["function_id"] = Store.selected_function_id;
        Store.plot.type = "between-path";
        path_highlight_mode_on = true;
        highlight_paths(this);
      }
      else if (data["action"] == "mixed-path") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "mixed-path";
        plot_data["selected_line_numbers"].push(this.line);
        plot_data["function_id"] = Store.selected_function_id;
        Store.plot.type = "mixed-path";
        path_highlight_mode_on = true;
        highlight_paths(this);
      }
      else if (data["action"] == "simple-path-plot" || data["action"] == "between-path-plot" || data["action"] == "mixed-path-plot") {
        // set the plot data globally
        //plot_data = data;
        Store.plot.type = data["type"];
        Store.plot.current_hash = path_plot_hash;
        console.log("plot data");
        console.log(data);
        generate_plot(this);
      }

      stop_loading();
    }
  },
  mounted(){
    var that = this;
    this.$root.$on("subatom-selected", function(dict){
      // resetting dropdown options upon subatom reselection
      if (Store.type_of_atom){
      var options = [];
      var atom_index = dict["atom"];
      var sub_index = dict["subatom"];
      var inst_points = that.tree[selected_binding][atom_index][sub_index];
      var inst_point_id = inst_points[0]["id"];

      var inst_points_list = [];
      for (var i=0; i<inst_points.length; i++){
        if (inst_points[i]["code_line"] == that.line){
          inst_points_list.push(inst_points[i]["id"]);
        }
      }

      var atom_type = Store.type_of_atom;
      if (atom_type == "simple"){
        //for a simple atom we now need all observations made at these points,
        //filtered by: calls, binding, atom, subatom
        //then we can calculate verdict severity for each of the observations
        var option = {text: 'Plot severity of observations from this point',
                      data: {action: "simple-severity-plot",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option);
        var option = {text: 'Plot observations from this point',
                      data: {action: "simple-observation-plot",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option);
        var option2 = {text: 'Highlight paths by average verdict severity',
                      data: {action: "simple-path",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option2);
      }
      else if (atom_type == "timeBetween" || atom_type == "mixed") {
        // we need the list of inst points that belong to the same atom, but other than the selected subatom
        var other_points_list = [];
        var subtree = that.tree[selected_binding][atom_index];
        for (subatom in subtree){
          if (subatom != sub_index){
            for (var i=0; i<subtree[subatom].length; i++){
              other_points_list.push({id: subtree[subatom][i]["id"],
                                      line: subtree[subatom][i]["code_line"]});
            }
          }
        }
        option = {text: 'Fix this point and select the other one',
                  data: {action: (atom_type=="timeBetween") ? "between-select" : "mixed-select",
                         type : (atom_type=="timeBetween") ? "between-select" : "mixed-select",
                         other_lines: other_points_list,
                         calls: Store.selected_calls,
                         binding: selected_binding,
                         atom: atom_index,
                         points: inst_points_list,
                         selected_line_numbers: [that.line]}};
        options.push(option);
      }
      that.options = options;}
    })

  }
})


var app = new Vue({
    el : "#app"
});
